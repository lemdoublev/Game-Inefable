// <auto-generated>
// Auto-generated by StoneAPI, do not modify.
// </auto-generated>

namespace Dropbox.Api.Paper
{
    using sys = System;
    using col = System.Collections.Generic;
    using re = System.Text.RegularExpressions;

    using enc = Dropbox.Api.Stone;

    /// <summary>
    /// <para>The cursor object</para>
    /// </summary>
    /// <seealso cref="ListPaperDocsResponse" />
    /// <seealso cref="ListUsersOnFolderResponse" />
    /// <seealso cref="ListUsersOnPaperDocResponse" />
    public class Cursor
    {
        #pragma warning disable 108

        /// <summary>
        /// <para>The encoder instance.</para>
        /// </summary>
        internal static enc.StructEncoder<Cursor> Encoder = new CursorEncoder();

        /// <summary>
        /// <para>The decoder instance.</para>
        /// </summary>
        internal static enc.StructDecoder<Cursor> Decoder = new CursorDecoder();

        /// <summary>
        /// <para>Initializes a new instance of the <see cref="Cursor" /> class.</para>
        /// </summary>
        /// <param name="value">The actual cursor value.</param>
        /// <param name="expiration">Expiration time of <paramref name="value" />. Some cursors
        /// might have expiration time assigned. This is a UTC value after which the cursor is
        /// no longer valid and the API starts returning an error. If cursor expires a new one
        /// needs to be obtained and pagination needs to be restarted. Some cursors might be
        /// short-lived some cursors might be long-lived. This really depends on the sorting
        /// type and order, e.g.: 1. on one hand, listing docs created by the user, sorted by
        /// the created time ascending will have undefinite expiration because the results
        /// cannot change while the iteration is happening. This cursor would be suitable for
        /// long term polling. 2. on the other hand, listing docs sorted by the last modified
        /// time will have a very short expiration as docs do get modified very often and the
        /// modified time can be changed while the iteration is happening thus altering the
        /// results.</param>
        public Cursor(string @value,
                      sys.DateTime? expiration = null)
        {
            if (@value == null)
            {
                throw new sys.ArgumentNullException("@value");
            }

            this.Value = @value;
            this.Expiration = expiration;
        }

        /// <summary>
        /// <para>Initializes a new instance of the <see cref="Cursor" /> class.</para>
        /// </summary>
        /// <remarks>This is to construct an instance of the object when
        /// deserializing.</remarks>
        [sys.ComponentModel.EditorBrowsable(sys.ComponentModel.EditorBrowsableState.Never)]
        public Cursor()
        {
        }

        /// <summary>
        /// <para>The actual cursor value.</para>
        /// </summary>
        public string Value { get; protected set; }

        /// <summary>
        /// <para>Expiration time of <see cref="Value" />.</para>
        /// <para>Some cursors might have expiration time assigned. This is a UTC value after
        /// which the cursor is no longer valid and the API starts returning an error. If
        /// cursor expires a new one needs to be obtained and pagination needs to be restarted.
        /// Some cursors might be short-lived some cursors might be long-lived.</para>
        /// <para>This really depends on the sorting type and order, e.g.:</para>
        /// <para>1. on one hand, listing docs created by the user, sorted by the created time
        /// ascending will have undefinite expiration because the results cannot change while
        /// the iteration is happening. This cursor would be suitable for long term
        /// polling.</para>
        /// <para>2. on the other hand, listing docs sorted by the last modified time will have
        /// a very short expiration as docs do get modified very often and the modified time
        /// can be changed while the iteration is happening thus altering the results.</para>
        /// </summary>
        public sys.DateTime? Expiration { get; protected set; }

        #region Encoder class

        /// <summary>
        /// <para>Encoder for  <see cref="Cursor" />.</para>
        /// </summary>
        private class CursorEncoder : enc.StructEncoder<Cursor>
        {
            /// <summary>
            /// <para>Encode fields of given value.</para>
            /// </summary>
            /// <param name="value">The value.</param>
            /// <param name="writer">The writer.</param>
            public override void EncodeFields(Cursor value, enc.IJsonWriter writer)
            {
                WriteProperty("value", value.Value, writer, enc.StringEncoder.Instance);
                if (value.Expiration != null)
                {
                    WriteProperty("expiration", value.Expiration.Value, writer, enc.DateTimeEncoder.Instance);
                }
            }
        }

        #endregion


        #region Decoder class

        /// <summary>
        /// <para>Decoder for  <see cref="Cursor" />.</para>
        /// </summary>
        private class CursorDecoder : enc.StructDecoder<Cursor>
        {
            /// <summary>
            /// <para>Create a new instance of type <see cref="Cursor" />.</para>
            /// </summary>
            /// <returns>The struct instance.</returns>
            protected override Cursor Create()
            {
                return new Cursor();
            }

            /// <summary>
            /// <para>Set given field.</para>
            /// </summary>
            /// <param name="value">The field value.</param>
            /// <param name="fieldName">The field name.</param>
            /// <param name="reader">The json reader.</param>
            protected override void SetField(Cursor value, string fieldName, enc.IJsonReader reader)
            {
                switch (fieldName)
                {
                    case "value":
                        value.Value = enc.StringDecoder.Instance.Decode(reader);
                        break;
                    case "expiration":
                        value.Expiration = enc.DateTimeDecoder.Instance.Decode(reader);
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }
        }

        #endregion
    }
}
